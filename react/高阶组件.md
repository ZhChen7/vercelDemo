# 高阶组件（HOC）

### 本文速览

- 高阶组件（HOC）基本概念
- 使用高阶组件的原因
- 高阶组件使用和编写结构



------





## HOC 基本概念

> 具体地说，**高阶组件是参数为组件，返回值为新组件的函数。**
>
> 高阶组件（HOC）是 React 中用于重用组件逻辑的高级技术。 HOC 本身不是 React API 的一部分。 它们是从 React 构思本质中浮现出来的一种模式。

~~~js
const EnhancedComponent = higherOrderComponent(WrappedComponent);
~~~

组件是将 props 转化成 UI ，然而高阶组件将一个组价转化成另外一个组件。

React在第三方组件库中非常常见，例如Redux的[`connect`](https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options) 和 Relay’s [`createFragmentContainer`](http://facebook.github.io/relay/docs/en/fragment-container.html)。



## 使用高阶组件的原因

> 在业务开发中，虽然不掌握高阶组件也可以完成项目的开发，但是如果我们能够灵活地使用高阶组件（加分项 ），可以让项目代码变得更加优雅，同时增强代码的复用性和灵活性，提升开发效率。

- 同时，了解高阶组件对我们理解各种 `React.js` 第三方库的原理很有帮助 。

**关于高阶组件能解决的问题可以简单概括成以下三个方面** ：

- 抽取重复代码，实现组件复用，常见场景：页面复用。
- 条件渲染，控制组件的渲染逻辑（渲染劫持），常见场景：权限控制。
- 捕获/劫持被处理组件的生命周期，常见场景：组件渲染性能追踪、日志打点。



## HOC 的作用 

**① 复用逻辑**：高阶组件更像是一个加工`react`组件的工厂，批量对原有组件进行**加工**，**包装**处理。我们可以根据业务需求定制化专属的`HOC`,这样可以解决复用逻辑。

**② 强化props**：这个是`HOC`最常用的用法之一，高阶组件返回的组件，可以劫持上一层传过来的`props`,然后混入新的`props`,来增强组件的功能。代表作`react-router`中的`withRouter`。

**③ 赋能组件**：`HOC`有一项独特的特性，就是可以给被`HOC`包裹的业务组件，提供一些拓展功能，比如说**额外的生命周期，额外的事件**，但是这种`HOC`，可能需要和业务组件紧密结合。典型案例`react-keepalive-router`中的 `keepaliveLifeCycle`就是通过`HOC`方式，给业务组件增加了额外的生命周期。

**④ 控制渲染**：劫持渲染是`hoc`一个特性，在`wrapComponent`包装组件中，可以对原来的组件，进行`条件渲染`，`节流渲染`，`懒加载`等功能，典型代表做`react-redux`中`connect`和 `dva`中 `dynamic` 组件懒加载。





# 高阶组件的实现

通常情况下，实现高阶组件的方式有以下两种:

- 属性代理(Props Proxy)
  - 返回一个无状态（stateless）的函数组件
  - 返回一个 class 组件
- 反向继承(Inheritance Inversion)

高阶组件实现方式的差异性决定了它们各自的应用场景：一个 `React` 组件包含了 `props`、`state`、`ref`、生命周期方法、`static`方法和`React` 元素树几个重要部分



## 属性代理(Props Proxy)

- 属性代理是最常见的实现方式，它本质上是使用组合的方式，通过将组件包装在容器组件中实现功能。
- 属性代理方式实现的高阶组件和原组件的生命周期关系完全是React父子组件的生命周期关系，所以该方式实现的高阶组件会影响原组件某些生命周期等方法。



### 操作 props

- 最简单的属性代理实现代码如下：

```js
// 返回一个无状态的函数组件
function HOC(WrappedComponent) {
  const newProps = { type: 'HOC' };
  return props => <WrappedComponent {...props} {...newProps}/>;
}

// 返回一个有状态的 class 组件
function HOC(WrappedComponent) {
  return class extends React.Component {
    render() {
      const newProps = { type: 'HOC' };
      return <WrappedComponent {...this.props} {...newProps}/>;
    }
  };
}
```

- 从上面代码可以看到，通过属性代理方式实现的高阶组件包装后的组件可以拦截到父组件传递过来的 `props`，提前对 `props` 进行一些操作，比如增加一个 `type` 属性。



### 抽象 state

> 简单来说 -->  就是把需要在原组件，通过state动态赋值的操作，抽象到高阶组件中通过props传值。

- 需要注意 的是，通过属性代理方式实现的高阶组件无法直接操作原组件的 `state`，但是可以通过 `props` 和回调函数对 `state` 进行抽象。️
- 常见的例子是实现非受控组件到[受控组件](https://link.juejin.cn/?target=https%3A%2F%2Fzh-hans.reactjs.org%2Fdocs%2Fforms.html%23controlled-components)的转变：

~~~js
const HOC = (WrappedComponent) => {
  return class extends Component {
      onChange = (data = {}) => {
          this.setState(data)
      }
    render() {
        const {name = ''} = this.state;
        const newProps = {
            name: {
                value: name,
                onChange: (e)=>this.onChange({name: e.target.value})
            }
        }
        return <WrappedComponent {...this.props} {...newProps}/>
    }
  }
}

class WrappedComponent extends Component{
    render(){
        const {name} = this.props;
       return <input {...name} />
    }
}

//高阶组件使用
export default HOC(WrappedComponent)
~~~





### 获取 refs 引用

为了访问 `DOM element` （`focus`事件、动画、使用第三方 DOM 操作库），有时我们会用到组件的 `ref` 属性，关于`refs` 的介绍详见[官方文档](https://link.juejin.cn?target=https%3A%2F%2Fzh-hans.reactjs.org%2Fdocs%2Frefs-and-the-dom.html)。

`ref` 属性只能声明在 class 类型的组件上，而无法声明在函数类型的组件上（因为无状态组件没有实例）。

通过属性代理方式实现的高阶组件无法直接获取原组件的 `refs` 引用，但是可以通过在原组件的`ref`回调函数中调用父组件传入的 `ref` 回调函数来获取原组件的`refs` 引用。

~~~js
const HOC = (WrappedComponent) => {
  return class extends Component {
    render() {
      return <WrappedComponent ref={this.onRef} {...this.props}></WrappedComponent>
    }
  }
}
~~~



### 获取原组件的 static 方法





### 通过 props 实现条件渲染





### 用其他元素包裹传入的组件







## 反向继承(Inheritance Inversion)



## 注意事项

> 高阶组件有一些需要注意的地方，对于 React 新手来说可能并不容易发现。

### 1、不要在 render 方法中使用 HOC

### 2、务必复制静态方法

### 3、Refs 不会被传递









## 总结 

- 高阶组件不是组件，它是一个将某个组件转换成另一个组件的纯函数。
- 高阶组件的主要作用是实现代码复用和逻辑抽象、对 `state` 和 `props` 进行抽象和操作、对组件进行细化（如添加生命周期）、实现渲染劫持等。在实际的业务场景中合理的使用高阶组件，可以提高开发效率和提升代码的可维护性。
- 高阶组件的实用性 使其频繁地被大量 `React.js` 相关的第三方库，如 `React-Redux`的 `connect` 方法、`React-Loadable`等所使用，了解高阶组件对我们理解各种 `React.js` 第三方库的原理很有帮助 。
- 高阶组件有两种实现方式，分别是属性代理和反向继承。它可以看作是装饰器模式在 `React` 中的实现：在不修改原组件的情况下实现组件功能的增强。
- 在进行业务代码开发前通常会对项目进行的一些特殊配置，有利于后期的工程开发，具体内容可参考 👉：[react + typescript 项目的定制化过程](https://juejin.cn/post/6844903922100862989#comment)。





参考：https://juejin.cn/post/6844904050236850184#heading-1