# React 协调算法 Reconciliation

### 本文速览

- React 协调算法 Reconciliation （diff算法）



------



## 前言

`React` 是一个用于构建用户界面的 `JavaScript` 库。它的核心原理是追踪组件中的状态的改变，然后将这些被更新的状态自动刷新到屏幕上。在 `React` 中有一个过程被称之为 `协调 reconciliation` 。也就是当我们调用 `setState` 方法，或是框架检测到 `state` or `props`变化后，便开始重新开始计算比对组件的前后状态，并渲染与之对应的改变的 UI。

React 官方文档提供了对其原理的[高阶概述](https://link.juejin.cn?target=https%3A%2F%2Freactjs.org%2Fdocs%2Freconciliation.html)：`React Element` ，生命周期方法，`render`方法，组件孩子节点的 `diff`算法的应用等 在 `React`中所扮演的角色。其中 render 方法所返回的 `React elements Tree`就是我们常常提到的 虚拟DOM `virtual DOM` 。

除以外，React 还有另外一棵内部实例树（组件实例，或 DOM 节点等），它被用来保存 state 状态。从 React16 开始 React 推出了新的内部实例树的实现 以及它的管理算法 统称为 `Fiber`





## 目的

当你使用React，在某一个时间点，你可以认为`render()`函数是在创建React元素树。在下一状态或属性更新时，`render()`函数将返回一个不同的React元素树。React需要算出如何高效更新UI以匹配最新的树。

有一些通用的解决方案，对于生成最小操作数的这个算法问题，以将一棵树转换为另一棵树。然而，在[state of the art algorithms](http://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf) 中有时间复杂度为O(n3)，在这里n代表树中元素个数。

若我们在React中使用，展示1000个元素则需要进行10亿次的比较。这太过昂贵。与此不同，React基于两点假设，实现了一个启发的O(n)算法：

1. 两个不同类型的元素将产生不同的树。
2. 开发者可以使用`key`属性来提示哪些子元素贯穿不同渲染是稳定的。

实践中，上述这些假设适用于大部分应用场景。







参考：https://juejin.cn/post/6844903985652957192